Brian Goetz의 저서 Java Concurrency in Practice에서 등장한 공식으로
스레드 수=사용가능한 코어의 수 *(1+대기시간/서비스시간)이라는 공식이 있습니다.
이때 대기시간은 하나의 작업이 완료되는데 소모대는 대기시간이고 서비스 시간은 작업이 실제로 동작중인 시간을 의미합니다.
제 컴퓨터의 cpu는 intel i3-7100u로 코어가 4개이고, 이는 int numOfCores = Runtime.getRuntime().availableProcessors(); 이 코드를 통해서
확인해 본 결과와 일치하였습니다.
java Crawler https://www.naver.com 2 2 로 실행한 결과
전체 프로그램이 실행되는데 13856 millisecond
1번 스레드가 프로그램 종료까지 13703 밀리초가 걸렸고,
2번 스레드가 프로그램 종료까지 13695 밀리초가 걸렸음을 확인하였습니다.
이것은 쓰레드가 실행하는데 걸린 서비스 시간과 대기시간을 모두 합산한 시간이고
대기시간은 쓰레드가 공동으로 사용하는 pending urls에 접근하기 위해 대기하는 시간과
httpurlconnection객체가 url을 받아 접속할 때 대기시간이 발생하게 된다.
첫번째 대기시간은 280밀리초, 두번째 url관련 대기시간은 432밀리초가 걸렸습니다.
때문에 대기시간은 이 둘을 합쳐 712
대략 13700에서 700을 뺀다면 13000으로 이것을 서비스시간으로 생각해도 될 것 같다.
그럼 이 값들을 위의 식에 대입한다면
4*(1+700/13000)는 대략 4.05정도의 값이 나오고 대략 4~5개의 스레드 사용이 적당하다고 판단될 수 있을것 같습니다.
하지만 실제로 사용하였을 때 쓰레드를 100개 생성하였을 때 대기중인 쓰레드가 약 88개정도까지도 관측이 되었고
쓰레드를 1000개 생성하여 작동하였을 땐 대기중인 쓰레드가 986개정도까지도 내려감을 확인이 되었습니다.
때문에 계산한 값보다 더 많은 쓰레드가 활동함으고 있음을 볼 수 있는데 이것을 참고한다면
대략 10~15개 정도의 쓰레드를 사용한다면 대부분의 스레드가 작업에 참여중인 프로그램이 될 것이라고 생각합니다.